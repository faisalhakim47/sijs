const isSymbolSuppoted = 'Symbol' in window

if (!isSymbolSuppoted) window['Symbol'] = function Symbol(token) {
  return isFn(window['Symbol'])
    ? window['Symbol'][token] || ('@@' + token)
    : ('@@' + token)
}

if (!Symbol.observable) Symbol.observable = Symbol('@@observable')

export interface Observer<Val, ErrVal = Error> {
  // Receives the subscription object when `subscribe` is called
  start?(subscription: Subscription)
  // Receives the next value in the sequence
  next(value: Val)
  // Receives the sequence error
  error?(errorVal: ErrVal)
  // Receives a completion notification
  complete?()
}

export class Subscription {
  constructor(
    public unsubscribe: () => void,
    public getClosed = () => false
  ) { }
  get closed() {
    return this.getClosed()
  }
}

export class SubscriptionObserver<Val, ErrVal = Error> {
  constructor(
    // Sends the next value in the sequence
    public next: (value: Val) => void,
    // Sends the sequence error
    public error: (errorValue: ErrVal) => void,
    // Sends the completion notification
    public complete: () => void,
    // A boolean value indicating whether the subscription is closed
    public getClosed: () => boolean
  ) { }
  get closed() {
    return this.getClosed()
  }
}

export type SubscribtionFunction<Val, ErrVal = Error> =
  (observer: SubscriptionObserver<Val, ErrVal>) => ((() => void) | Subscription)

function isFn(testObject) {
  return typeof testObject === 'function'
}

function isObject(testObject) {
  return !!testObject && typeof testObject === 'object'
}

export class Observable<Val, ErrVal = Error> {
  static of<Val, ErrVal = Error>(...items) {
    const Obs = isFn(this) ? this : Observable
    return new Obs<Val, ErrVal>((observer) => {
      const length = items.length
      for (let index = 0; index < length; index++) {
        observer.next(items[index])
      }
      return () => { }
    })
  }

  static from<Val, ErrVal = Error>(object: Observable<Val, ErrVal> | Iterable<Val>) {
    if (object == undefined) throw new TypeError('null and Undefined is not allowed')

    const Obs = isFn(this) ? this : Observable

    if (Array.isArray(object))
      return new Obs<Val, ErrVal>((observer) => {
        const length = object.length
        for (let index = 0; index < length; index++) {
          observer.next(object[index])
        }
        return () => { }
      })

    if (Symbol.observable in object) {
      const getObservable = object[Symbol.observable]
      if (isFn(getObservable)) {
        const obsResult = getObservable()
        if (!isObject(obsResult) && !isFn(obsResult)) {
          throw new TypeError('Throws if the return value of Symbol.observable is not an object')
        }
        if (isFn(obsResult)) return obsResult() as Observable<Val, ErrVal>
        const obs: Observable<Val, ErrVal> = obsResult
        return new Obs<Val, ErrVal>((observer) => {
          return obs.subscribe(observer)
        })
      } else throw new TypeError('Symbol.observable must be a function')
    }

    if (object[Symbol.iterator])
      return new Obs((observer) => {
        const iterator: Iterator<Val> = object[Symbol.iterator]()
        let current: IteratorResult<Val>
        do {
          current = iterator.next()
          observer.next(current.value)
        } while (!current.done)
        return () => { }
      })
  }

  constructor(
    private subscriber: SubscribtionFunction<Val, ErrVal>
  ) {
    if (!isFn(subscriber)) throw new TypeError()
  }

  subscribe(
    observerOrNext: Observer<Val, ErrVal>,
    errorFn?: (errorValue: ErrVal) => void,
    completeFn?: () => void
  ): Subscription {
    let observer: Observer<Val, ErrVal> = {
      next() { }
    }

    if (typeof observerOrNext === 'function') {
      observer.next = observerOrNext
      observer.error = errorFn
      observer.complete = completeFn
    } else if (observerOrNext && typeof observerOrNext === 'object') {
      observer = observerOrNext
    } else {
      throw new TypeError('Throws if observer is not an object')
    }

    let isSubscriptionClosed = false
    let cleanup: () => void
    function unsubscribe() {
      if (isSubscriptionClosed) return
      if (isFn(cleanup)) cleanup()
      isSubscriptionClosed = true
    }
    const subscription: Subscription = new Subscription(
      unsubscribe,
      () => isSubscriptionClosed
    )

    if (isFn(observer.start)) {
      observer.start(subscription)
    }

    const subscribtionObserver = new SubscriptionObserver<Val, ErrVal>(
      (value) => {
        if (isSubscriptionClosed) return
        if (observer.next) {
          try { return observer.next(value) }
          catch (error) {
            unsubscribe()
            throw error
          }
        }
      },
      (errorVal) => {
        unsubscribe()
        if (isFn(observer.error)) observer.error(errorVal)
        else throw errorVal
      },
      () => {
        unsubscribe()
        if (isFn(observer.complete)) observer.complete()
      },
      () => isSubscriptionClosed
    )

    try {
      if (!isSubscriptionClosed) {
        cleanup = this.subscriber(subscribtionObserver) as () => void
      }
    } catch (error) {
      subscribtionObserver.error(error)
    }

    if (cleanup && isFn(cleanup['unsubscribe'])) {
      cleanup = cleanup['unsubscribe']
    }

    if (!isFn(cleanup) && cleanup != undefined) {
      throw new TypeError('Subscriber return types: Non callable, non-subscription objects cannot be returned')
    }

    if (isSubscriptionClosed) {
      unsubscribe()
      if (isFn(cleanup)) cleanup()
    }

    return subscription
  }

  [Symbol.observable]() {
    return this
  }
}
